# [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)
## Problem Description
Given a non-empty array of integers, return the k most frequent elements.

For example,
Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.

Note: 
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.

## Solution
- use hashmap + bucket sort
```
  class Solution {
      public List<Integer> topKFrequent(int[] nums, int k) {
          List<Integer>[] bucket = new List[nums.length+1];
          Map<Integer, Integer>  freqMap = new HashMap<>();

          for (int num : nums) {
              freqMap.put(num, freqMap.getOrDefault(num, 0)+1);
          }

          for (int key : freqMap.keySet()) {
              int freq = freqMap.get(key);
              if (bucket[freq] == null) {
                  bucket[freq] = new ArrayList<>();
              }
              bucket[freq].add(key);
          }

          List<Integer> res = new ArrayList<>();
          for (int i = bucket.length - 1; i >= 0 && res.size() < k; i--) {
              int n = k - res.size();
              if (bucket[i] != null) {
                  if (bucket[i].size() <= n) {
                      res.addAll(bucket[i]);
                  } else {
                      res.addAll(bucket[i].subList(0, n));
                  }
              }
          }
          return res;
      }
  }
```

# Data structure / Algorithm / Java knowledge Used
- [Java List](http://www.geeksforgeeks.org/list-interface-java-examples/)
- [bucket sort](http://www.geeksforgeeks.org/bucket-sort-2/)
